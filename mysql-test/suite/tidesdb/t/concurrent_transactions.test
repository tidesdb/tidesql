--echo #
--echo # TidesDB concurrent transaction tests
--echo # Tests multi-connection isolation and MVCC behavior
--echo #

# Check if TidesDB is available
--disable_query_log
--error 0,1286
CREATE TABLE tidesdb_check (id INT) ENGINE=TidesDB;
--enable_query_log
if (`SELECT COUNT(*) = 0 FROM information_schema.tables WHERE table_name = 'tidesdb_check'`)
{
  --skip TidesDB storage engine not available
}
DROP TABLE IF EXISTS tidesdb_check;

CREATE TABLE t1 (id INT PRIMARY KEY, val INT) ENGINE=TidesDB;
INSERT INTO t1 VALUES (1, 100), (2, 200), (3, 300);

connect (conn1, localhost, root,,);
connect (conn2, localhost, root,,);

--echo # Test 1: Concurrent inserts to different keys (no conflict)
connection conn1;
START TRANSACTION;
INSERT INTO t1 VALUES (10, 1000);

connection conn2;
START TRANSACTION;
INSERT INTO t1 VALUES (20, 2000);
COMMIT;

connection conn1;
COMMIT;

connection default;
SELECT * FROM t1 WHERE id IN (10, 20) ORDER BY id;

--echo # Test 2: Multiple readers don't block each other
connection conn1;
START TRANSACTION;
SELECT COUNT(*) FROM t1;

connection conn2;
START TRANSACTION;
SELECT COUNT(*) FROM t1;
COMMIT;

connection conn1;
COMMIT;

--echo # Test 3: Read-only transaction sees consistent snapshot
--echo # conn2 inserts a new row while conn1 has a snapshot
connection conn1;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT COUNT(*) FROM t1 WHERE id = 50;

connection conn2;
INSERT INTO t1 VALUES (50, 5000);

connection conn1;
--echo # conn1 should not see the new row under RR
SELECT COUNT(*) FROM t1 WHERE id = 50;
COMMIT;

--echo # After commit, new read sees the inserted row
connection conn1;
SELECT val FROM t1 WHERE id = 50;

--echo # Test 4: Writer sees own changes
connection conn1;
START TRANSACTION;
INSERT INTO t1 VALUES (30, 3000);
SELECT val FROM t1 WHERE id = 30;
ROLLBACK;

--echo # After rollback, row should not exist
SELECT * FROM t1 WHERE id = 30;

--echo # Cleanup
connection default;
disconnect conn1;
disconnect conn2;
DROP TABLE t1;
