--echo #
--echo # Test SELECT FOR UPDATE SKIP LOCKED (HA_CAN_SKIP_LOCKED)
--echo #

# Check if TidesDB is available
--disable_query_log
--error 0,1286
CREATE TABLE tidesdb_check (id INT) ENGINE=TidesDB;
--enable_query_log
if (`SELECT COUNT(*) = 0 FROM information_schema.tables WHERE table_name = 'tidesdb_check'`)
{
  --skip TidesDB storage engine not available
}
DROP TABLE tidesdb_check;

# Create test table
CREATE TABLE t1 (
  id INT PRIMARY KEY,
  value VARCHAR(100)
) ENGINE=TidesDB;

INSERT INTO t1 VALUES (1, 'row1');
INSERT INTO t1 VALUES (2, 'row2');
INSERT INTO t1 VALUES (3, 'row3');
INSERT INTO t1 VALUES (4, 'row4');
INSERT INTO t1 VALUES (5, 'row5');

--echo # Test 1: Basic SELECT FOR UPDATE
START TRANSACTION;
SELECT * FROM t1 WHERE id = 1 FOR UPDATE;
COMMIT;

--echo # Test 2: SELECT FOR UPDATE SKIP LOCKED
# TidesDB MVCC never blocks, so SKIP LOCKED is naturally supported
START TRANSACTION;
SELECT * FROM t1 WHERE id IN (1, 2, 3) FOR UPDATE SKIP LOCKED;
COMMIT;

--echo # Test 3: SELECT FOR UPDATE NOWAIT
START TRANSACTION;
SELECT * FROM t1 WHERE id = 2 FOR UPDATE NOWAIT;
COMMIT;

--echo # Test 4: Concurrent access with SKIP LOCKED
--connect (con1, localhost, root,,)
--connection con1
START TRANSACTION;
SELECT * FROM t1 WHERE id = 1 FOR UPDATE;

--connection default
# This should work because TidesDB MVCC doesn't block
START TRANSACTION;
SELECT * FROM t1 WHERE id IN (1, 2) FOR UPDATE SKIP LOCKED;
COMMIT;

--connection con1
COMMIT;
--disconnect con1

--connection default

--echo # Cleanup
DROP TABLE t1;

--echo #
--echo # SKIP LOCKED tests completed!
--echo #
