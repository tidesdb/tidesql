#
# Test Clustered Index (HA_CLUSTERED_INDEX for primary key)
#
DROP TABLE tidesdb_check;
CREATE TABLE t1 (
id INT PRIMARY KEY,
a INT,
b VARCHAR(100),
INDEX idx_a (a)
) ENGINE=TidesDB;
INSERT INTO t1 VALUES (1, 100, 'row1');
INSERT INTO t1 VALUES (2, 200, 'row2');
INSERT INTO t1 VALUES (3, 300, 'row3');
INSERT INTO t1 VALUES (4, 400, 'row4');
INSERT INTO t1 VALUES (5, 500, 'row5');
# Test 1: Primary key lookup (uses clustered index)
EXPLAIN SELECT * FROM t1 WHERE id = 3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	const	PRIMARY	PRIMARY	4	const	1	
SELECT * FROM t1 WHERE id = 3;
id	a	b
3	300	row3
# Test 2: Primary key range scan
EXPLAIN SELECT * FROM t1 WHERE id BETWEEN 2 AND 4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	4	NULL	2	Using where with pushed condition
SELECT * FROM t1 WHERE id BETWEEN 2 AND 4 ORDER BY id;
id	a	b
2	200	row2
# Test 3: Secondary index lookup (not clustered)
EXPLAIN SELECT * FROM t1 WHERE a = 300;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	idx_a	idx_a	5	const	1	
SELECT * FROM t1 WHERE a = 300;
id	a	b
3	300	row3
# Test 4: Covering index scan on secondary index
EXPLAIN SELECT a FROM t1 WHERE a > 200;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx_a	idx_a	5	NULL	2	Using where with pushed condition; Using index
SELECT a FROM t1 WHERE a > 200 ORDER BY a;
a
500
# Test 5: Full table scan via clustered index
EXPLAIN SELECT * FROM t1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	5	
SELECT * FROM t1 ORDER BY id;
id	a	b
1	100	row1
2	200	row2
3	300	row3
4	400	row4
5	500	row5
# Test 6: Verify pk_is_clustering_key behavior
SELECT * FROM t1 FORCE INDEX (PRIMARY) WHERE id >= 1 ORDER BY id;
id	a	b
1	100	row1
2	200	row2
3	300	row3
4	400	row4
5	500	row5
# Cleanup
DROP TABLE t1;
#
# Clustered index tests completed!
#
