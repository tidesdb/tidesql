#
# TidesDB concurrent transaction tests
# Tests multi-connection isolation and MVCC behavior
#
DROP TABLE IF EXISTS tidesdb_check;
CREATE TABLE t1 (id INT PRIMARY KEY, val INT) ENGINE=TidesDB;
INSERT INTO t1 VALUES (1, 100), (2, 200), (3, 300);
connect  conn1, localhost, root,,;
connect  conn2, localhost, root,,;
# Test 1: Concurrent inserts to different keys (no conflict)
connection conn1;
START TRANSACTION;
INSERT INTO t1 VALUES (10, 1000);
connection conn2;
START TRANSACTION;
INSERT INTO t1 VALUES (20, 2000);
COMMIT;
connection conn1;
COMMIT;
connection default;
SELECT * FROM t1 WHERE id IN (10, 20) ORDER BY id;
id	val
10	1000
20	2000
# Test 2: Multiple readers don't block each other
connection conn1;
START TRANSACTION;
SELECT COUNT(*) FROM t1;
COUNT(*)
5
connection conn2;
START TRANSACTION;
SELECT COUNT(*) FROM t1;
COUNT(*)
5
COMMIT;
connection conn1;
COMMIT;
# Test 3: Read-only transaction sees consistent snapshot
# conn2 inserts a new row while conn1 has a snapshot
connection conn1;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT COUNT(*) FROM t1 WHERE id = 50;
COUNT(*)
0
connection conn2;
INSERT INTO t1 VALUES (50, 5000);
connection conn1;
# conn1 should not see the new row under RR
SELECT COUNT(*) FROM t1 WHERE id = 50;
COUNT(*)
0
COMMIT;
# After commit, new read sees the inserted row
connection conn1;
SELECT val FROM t1 WHERE id = 50;
val
5000
# Test 4: Writer sees own changes
connection conn1;
START TRANSACTION;
INSERT INTO t1 VALUES (30, 3000);
SELECT val FROM t1 WHERE id = 30;
val
3000
ROLLBACK;
# After rollback, row should not exist
SELECT * FROM t1 WHERE id = 30;
id	val
# Cleanup
connection default;
disconnect conn1;
disconnect conn2;
DROP TABLE t1;
