#
# Test Index Condition Pushdown (ICP) and Multi-Range Read (MRR)
#
DROP TABLE tidesdb_check;
CREATE TABLE t1 (
id INT PRIMARY KEY,
a INT,
b INT,
c VARCHAR(100),
INDEX idx_a (a),
INDEX idx_ab (a, b)
) ENGINE=TIDESDB;
# Insert test data
INSERT INTO t1 VALUES (1, 10, 100, 'row1');
INSERT INTO t1 VALUES (2, 10, 200, 'row2');
INSERT INTO t1 VALUES (3, 20, 100, 'row3');
INSERT INTO t1 VALUES (4, 20, 200, 'row4');
INSERT INTO t1 VALUES (5, 30, 100, 'row5');
INSERT INTO t1 VALUES (6, 30, 200, 'row6');
INSERT INTO t1 VALUES (7, 40, 100, 'row7');
INSERT INTO t1 VALUES (8, 40, 200, 'row8');
INSERT INTO t1 VALUES (9, 50, 100, 'row9');
INSERT INTO t1 VALUES (10, 50, 200, 'row10');
#
# Test 1: Basic ICP - condition on indexed column
#
EXPLAIN SELECT * FROM t1 WHERE a = 20 AND b > 150;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	idx_a,idx_ab	idx_a	5	const	1	Using where
SELECT * FROM t1 WHERE a = 20 AND b > 150;
id	a	b	c
4	20	200	row4
#
# Test 2: ICP with composite index
#
EXPLAIN SELECT * FROM t1 WHERE a BETWEEN 20 AND 40 AND b = 100;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx_a,idx_ab	idx_ab	10	NULL	1	
SELECT * FROM t1 WHERE a BETWEEN 20 AND 40 AND b = 100;
id	a	b	c
3	20	100	row3
5	30	100	row5
7	40	100	row7
#
# Test 3: Covering index scan (keyread optimization)
#
EXPLAIN SELECT a, b FROM t1 WHERE a > 30;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx_a,idx_ab	idx_ab	5	NULL	5	Using where; Using index
SELECT a, b FROM t1 WHERE a > 30;
a	b
40	100
40	200
50	100
50	200
#
# Test 4: ICP with non-indexed condition
#
EXPLAIN SELECT * FROM t1 WHERE a = 30 AND c LIKE 'row%';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	idx_a,idx_ab	idx_a	5	const	1	Using where
SELECT * FROM t1 WHERE a = 30 AND c LIKE 'row%';
id	a	b	c
5	30	100	row5
6	30	200	row6
#
# Test 5: Multi-Range Read with IN clause
#
EXPLAIN SELECT * FROM t1 WHERE a IN (10, 30, 50);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx_a,idx_ab	idx_a	5	NULL	3	
SELECT * FROM t1 WHERE a IN (10, 30, 50) ORDER BY id;
id	a	b	c
1	10	100	row1
2	10	200	row2
5	30	100	row5
6	30	200	row6
9	50	100	row9
10	50	200	row10
#
# Test 6: Range scan with ICP
#
EXPLAIN SELECT * FROM t1 WHERE a >= 20 AND a <= 40 AND b < 150;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx_a,idx_ab	idx_ab	10	NULL	1	
SELECT * FROM t1 WHERE a >= 20 AND a <= 40 AND b < 150 ORDER BY id;
id	a	b	c
3	20	100	row3
5	30	100	row5
7	40	100	row7
#
# Test 7: Verify ICP is being used (check handler stats)
#
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 20 AND b > 150;
id	a	b	c
4	20	200	row4
# Handler_read_key should show index usage
SHOW STATUS LIKE 'Handler_read%';
Variable_name	Value
Handler_read_first	0
Handler_read_key	1
Handler_read_last	0
Handler_read_next	2
Handler_read_prev	0
Handler_read_retry	0
Handler_read_rnd	0
Handler_read_rnd_deleted	0
Handler_read_rnd_next	0
#
# Test 8: Join with MRR (Batched Key Access)
#
CREATE TABLE t2 (
id INT PRIMARY KEY,
t1_a INT,
INDEX idx_t1_a (t1_a)
) ENGINE=TIDESDB;
INSERT INTO t2 VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
# This join can use BKA/MRR
SET optimizer_switch='mrr=on,mrr_cost_based=off';
EXPLAIN SELECT t1.*, t2.id as t2_id FROM t1, t2 WHERE t1.a = t2.t1_a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	index	idx_t1_a	idx_t1_a	5	NULL	5	Using where; Using index
1	SIMPLE	t1	ref	idx_a,idx_ab	idx_a	5	test.t2.t1_a	2	
SELECT t1.id, t1.a, t2.id as t2_id FROM t1, t2 WHERE t1.a = t2.t1_a ORDER BY t1.id;
id	a	t2_id
1	10	1
2	10	1
3	20	2
4	20	2
5	30	3
6	30	3
7	40	4
8	40	4
9	50	5
10	50	5
SET optimizer_switch=DEFAULT;
# Cleanup
DROP TABLE t2;
DROP TABLE t1;
#
# ICP and MRR tests completed!
#
